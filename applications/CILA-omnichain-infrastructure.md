# EOS Network Foundation Grant Proposal

- **Project Name:** CILA - Omnichain Infrastructure
- **Team Name:** Collective Intelligence Labs Inc.
- **EOS Payment Address:** colintlabsai
- **[Level](https://github.com/eosnetworkfoundation/grant-framework#grant-levels):** 3
- **Pomelo Grant(s):** None
- **Project is Open-Source:** Yes
- **Project was part of Token sale:** No
- **Repository where Project resides:** https://github.com/Collective-Intelligence-Labs

## Contact

- **Contact Name:** Alex Shkor
- **Contact Email:** alex@cilabs.ai
- **Website:** https://collectiveintelligence.dev/


## Project Overview :page_facing_up:

### Overview

 **Name:** CILA - omnichain smart contracts infrastructure
- **Brief Description:** CILA enables the deployment of omnichain smart contracts that operate across multiple chains concurrently while maintaining full data consistency and a shared state.
- **Relationship to EOS Network / Antelope:** We deploy CILA event centric execution envitoment to include EOS into omnichain smart contracts infrastructure.
- **Reason for Interest:** We believe that his is the most important piece of technology we can work on, and we belive that it will bring value for the whole web3 ecosystem, uniting network, and creating a real competition for the efficient execution of omnichain smart contract - and in this competition we beleive EOS can be rather efficient.

The goal of this project is to implement an omnichain smart contract infrastructure support for EOS ecosystem. 🌐🤖 This will include the implementation of CQRS + Event Sourcing execution environment plus an example omnichain smart-contract. The implementation will be done using EOS smart-contracts implementation as a smart-contract. The implementation will include implementing Protobuf support on-chain, serialization/deserialization, aggregated repository, event store, command/operations dispatcher, snapshots store and events emitter. 🛠️👨‍💻

### Introduction

This project aims to add an omnichain smart contract infrastructure support for EOS ecosystem by implementing a CQRS + Event Sourcing execution environment. CQRS (Command Query Responsibility Segregation) is a design pattern that separates the command and query responsibilities of an application. Event Sourcing is a design pattern that represents the state of an application as a series of events that are stored in an event store. 🧬💻

### Implementation
The implementation of the omnichain smart contract infrastructure will be done using C++ EOS implementation as a smart-contract. The implementation will include the following components:

#### Protobuf support on-chain
Protobuf is a language-agnostic binary serialization format that allows developers to define structured data schemas. The implementation will include support for Protobuf on-chain, which will enable developers to define smart contract interfaces using Protobuf. 🤖💾

#### Aggregate Repository
Aggregate Repository is a data storage module that manages the state and storage of aggregate objects. It provides methods for creating, reading, updating, and deleting aggregates. 📈📊

#### Event Store
An event store is a database that stores events in the order they occurred. The implementation will include an event store, which will store all the events generated by the smart contract. 🗂️📑

#### Command/operations Dispatcher
A command/operations dispatcher is a component that receives commands/operations and dispatches them to the appropriate handler. The implementation will include a command/operations dispatcher, which will enable developers to define command/operation handlers for the smart contract. 🚚👨‍✈️

#### Events Emitter
An events emitter is a component that emits events. The implementation will include an events emitter, which will enable developers to define event handlers for the smart contract. 📣🔊

## Conclusion
The completion of this project will provide a powerful infrastructure for developers to build customized omnichain smart contracts on the EOS ecosystem. 💪👨‍💼

![architecture](https://i.imgur.com/QsmzpZR.png)

## 🚀 Technology Stack

**Programming Language** - C++ 

**Blockchain Framework** - EOS ⛓️

**Virtual Machine** - WebAssembly (WASM) 🕸️

**Serialization** - Protocol Buffers (protobuf) 📜: a language-agnostic data serialization format that allows for efficient and interoperable communication between different services and systems.

**Design Patterns**:
- Event Sourcing 📝: a pattern that captures all changes to an application state as a sequence of events, which can be used to reconstruct the state at any point in time.
- Command Query Responsibility Segregation (CQRS) 🧬: a pattern that separates the read and write concerns of an application, using separate models and interfaces for each.
- Saga pattern 🌟: a pattern for coordinating distributed transactions across multiple services, ensuring consistency and reliability.
- Domain-Driven Design (DDD) 🏰: a design approach that emphasizes the importance of the domain model in shaping the architecture of a software system.


**CI/CD** - GitHub Actions 🚀: a continuous integration and continuous deployment service that can automate the build and deployment processes.

**Containerization** - Docker 🐳: a tool that allows for the creation, deployment, and running of applications in containers, providing a consistent runtime environment across different platforms.


# Documentation for Core Copmpontents

# Dispatcher

The `Dispatcher` is a component of the omnichain smart contract infrastructure that receives commands/operations and dispatches them to the appropriate handler. The `Dispatcher` class enables developers to define command/operation handlers for the smart contract.

## Usage

The `Dispatcher` can be used in the implementation of the CQRS + Event Sourcing execution environment for EOS ecosystem. It receives commands/operations from external sources, such as a client or a node, and routes them to the appropriate command/operation handler.

To use the `Dispatcher`, developers first define a set of command/operation handlers for the smart contract. These handlers can be implemented as methods in a Rust struct. The `Dispatcher` class then instantiates this struct and routes commands/operations to the appropriate method based on the type of command/operation.

## Benefits

The `Dispatcher` provides a simple and flexible way to handle commands/operations in the smart contract. By defining a set of command/operation handlers, developers can easily add new functionality to the smart contract without having to modify the `Dispatcher` class` itself.

In addition, the `Dispatcher` enables developers to implement complex business logic in the smart contract by routing commands/operations to the appropriate handler. This allows for a more modular and maintainable codebase.

## Conclusion

The `Dispatcher` is a crucial component of the omnichain smart contract infrastructure. By enabling developers to define command/operation handlers for the smart contract, it provides a simple and flexible way to handle commands/operations. Its usage in the implementation of the CQRS + Event Sourcing execution environment for EOS ecosystem enables developers to implement complex business logic in a modular and maintainable codebase.

# EventStore 

## Description

The `EventStore`  is a database that stores events in the order they occurred. It is a crucial component of the omnichain smart contract infrastructure support for EOS ecosystem. The `EventStore` class enables the storage of all events generated by the smart contract, allowing for a complete historical record of all transactions and changes to the smart contract's state.

## Implementation

The `EventStore`  is implemented using a internal database. The `EventStore` stores events in the form of serialized binary data plus metadata, which can be easily deserialized for querying and analysis.

## Features

The `EventStore`  includes the following features:

- **Event storage:** The `EventStore` stores all events generated by the smart contract in the order they occurred, allowing for a complete historical record of all transactions and changes to the smart contract's state.

- **Querying:** The `EventStore` allows for easy querying of events using various criteria, such as time range, event type, or specific parameters.

- **Deserialization:** The `EventStore` can easily deserialize stored binary data for querying and analysis.

- **Scalability:** The `EventStore`  can handle large volumes of events and is designed for scalability.

## Benefits

The `EventStore` provides several benefits to developers building smart contracts on the EOS ecosystem, including:

- **Transparency:** The `EventStore` provides a complete historical record of all transactions and changes to the smart contract's state, ensuring transparency and accountability.

- **Auditability:** The `EventStore` allows for easy querying and analysis of events, enabling developers to audit the smart contract's behavior and ensure compliance with regulations and business rules.

- **Flexibility:** The `EventStore` can handle a wide range of event types and is designed for scalability, providing flexibility for developers building smart contracts on the EOS ecosystem.

## Conclusion

The `EventStore` is a crucial component of the omnichain smart contract infrastructure support for EOS ecosystem. It provides event storage, querying, deserialization, and scalability features, enabling developers to build transparent, auditable, and flexible smart contracts on the EOS ecosystem. The completion of this project will provide a powerful infrastructure for developers to build customized smart contracts on the EOS ecosystem, with the `EventStore` serving as a key component of this infrastructure.

# Snapshot Store

## Overview
The `Snapshot Store` is a component of the omnichain smart contract infrastructure that provides a way to store and retrieve snapshots of the smart contract state. A snapshot is a read-only view of the smart contract state at a particular point in time. Snapshots are useful for optimizing the performance of the smart contract by reducing the amount of data that needs to be read from the event store.

## Implementation
The implementation of the `Snapshot Store` includes the following components:

- `Snapshot Store`: The Snapshot Store is the primary component. It provides an interface for storing and retrieving snapshots of the smart contract state.
- `Snapshot Index`: The Snapshot Index is a data structure that is used to index snapshots by their version. It allows for efficient retrieval of the latest snapshot.
- `Snapshot Writer`: The Snapshot Writer is a component that is used to write snapshots to the Snapshot Store. It receives the current state of the smart contract and writes it to the Snapshot Store as a snapshot.
- `Snapshot Reader`: The Snapshot Reader is a component that is used to read snapshots from the Snapshot Store. It receives a snapshot version and returns a read-only view of the smart contract state at that version.

## Conclusion
The `Snapshot Store` provides a way to store and retrieve snapshots of the smart contract state, which can be used to optimize the performance of the smart contract. The implementation includes the `Snapshot Store`, `Snapshot Index`, `Snapshot Writer`, and `Snapshot Reader` components. The completion of this component will provide a pefrormance optmization for omnichain smart contracts on the EOS ecosystem.

# Aggregate

The `Aggregate` is a core component of the CQRS + Event Sourcing design pattern. It represents the current state of an entity and is responsible for handling commands and producing events.

## Description

An `Aggregate` is a stateful object that represents a single entity in the system. It maintains its state by applying events to its internal state. A new state can be generated by applying new events to the existing state. 

In the context of the EOS ecosystem, an `Aggregate` is implemented as a Rust struct that contains its internal state and a set of methods to apply events and handle commands.

## Implementation

The `Aggregate` is implemented using the following components:

### Internal state

The internal state of an `Aggregate` is represented as a Rust struct. The struct contains all the data necessary to represent the current state of the entity.

### Command handling

The `Aggregate` contains a set of methods to handle commands. These methods accept a command object as input and return a set of events that represent the result of executing the command.

### Event sourcing

The `Aggregate` implements event sourcing by maintaining a list of events that have been applied to the internal state. When a new command is received, the `Aggregate` applies the appropriate events to generate a new state.

### Snapshotting

The `Aggregate` implements snapshotting by periodically storing a snapshot of its internal state. When an `Aggregate` is retrieved from its event stream, it can be initialized with the latest snapshot and then apply only the events that occurred after the snapshot.

## Conclusion

The `Aggregate` is a core component of the CQRS + Event Sourcing design pattern. It represents the current state of an entity and is responsible for handling commands and producing events. The implementation of the `Aggregate` in the EOS ecosystem provides a powerful mechanism for building complex and scalable smart contracts.


# AggregateState 

The `AggregateState` represents the state of an aggregate object in the event sourcing pattern. It is responsible for maintaining the current state of the aggregate object by processing the events that have occurred in the past.

### Properties

- `id`: The unique identifier of the aggregate object.
- `version`: The version of the aggregate object.
- `events`: The list of events that have occurred in the past.

### Methods

- `apply_event(event)`: Applies the given event to the current state of the aggregate object. This method updates the state of the aggregate object based on the event that occurred.
- `get_version()`: Returns the version of the aggregate object.
- `get_events()`: Returns the list of events that have occurred in the past.

### Usage

To use the `AggregateState` , you must first create an instance of it and initialize it with the current state of the aggregate object. You can then apply events to the aggregate object by calling the `apply_event()` method.

## Diagramm

Architcture Overview Diagramm
![Diagramm](https://i.imgur.com/nWGtuEc.png)

Flow Diagramm

![Diagramm](https://i.imgur.com/1jeLNo1.png)

Command Processing Flow Diagramm

```sql
 +------------+       +------------+       +-----------------+       +-------------------+       +-------------+
 | Application|       |   Router   |       |Execution Chain  |       |  Event Relay Node |       | Aggregation |
 +------------+       +------------+       +-----------------+       +-------------------+       +-------------+
        |                    |                    |                            |                               |
        |   Command Request  |                    |                            |                               |
        |------------------> |                    |                            |                               |
        |                    |                    |                            |                               |
        |   Command Handler  |                    |                            |                               |
        |------------------> |                    |                            |                               |
        |                    |   Command Request  |                            |                               |
        |                    |------------------->|                            |                               |
        |                    |                    |  Execute Command (CQRS)    |                               |
        |                    |                    |--------------------------->|                               |
        |                    |                    |                            |     Store Event (ES)          |
        |                    |                    |                            |-----------------------------> |
        |                    |                    |                            |                               |
        |                    |                    |                            |   Broadcast Event to          |
        |                    |                    |                            |     Other Chains              |
        |                    |                    |                            |--------------------------->   |
        |                    |                    |                            |                               |
        |                    |                    |                            |  Transmit Event to            |
        |                    |                    |                            |     Aggregation Cluster       |
        |                    |                    |                            |-----------------------------> |
        |                    |                    |                            |                               |
        |                    |                    |                            |   Process Events and          |
        |                    |                    |                            |     Produce Aggregated Data   |
        |                    |                    |                            |<----------------------------- |
        |                    |                    |                            |                               |
        |                    |                    |                            |     Return Aggregated Data    |
        |                    |                    |                            |<----------------------------- |
        |                    |                    |                            |                               |

```

# API Documentation

### Domain

#### Aggregate

- `AggregateState`

- `Actions`
  - `create() -> void`: Creates a new instance of AggregateState.
  - `apply_events(events: vector<DomainEvent>) -> void`: Applies a list of domain events to the aggregate state.
  - `clear() -> void`: Clears the state of the aggregate.

#### DomainEvent

- `Actions`
  - `create(evnt_type: DomainEventType, evnt_payload: vector<char>) -> void`: Creates a new instance of DomainEvent.
  - `serialize() -> vector<char>`: Serializes the domain event to a byte array.

#### DomainEventType

- `Variants`
  - `NFT_MINTED`
  - `NFT_TRANSFERED`

#### Entities

##### NFT

- `Fields`
  - `hash: checksum256`: The unique hash of the NFT.
  - `owner: name`: The account name of the owner of the NFT.

- `Actions`
  - `create(hash: checksum256, owner: name) -> void`: Creates a new instance of NFT.
  - `get_hash() -> checksum256`: Returns the hash of the NFT.
  - `get_owner() -> name`: Returns the owner of the NFT.
  - `transfer(new_owner: name) -> void`: Transfers the ownership of the NFT to a new owner.

### Application

#### Command

- `Fields`
  - `cmd_type: CommandType`
  - `cmd_payload: vector<char>`

- `Actions`
  - `create(cmd_type: CommandType, cmd_payload: vector<char>) -> void`: Creates a new instance of Command.
  - `serialize() -> vector<char>`: Serializes the command to a byte array.

#### CommandType

- `Variants`
  - `MINT_NFT`
  - `TRANSFER_NFT`

#### Service

##### CommandDispatcher

- `Actions`
  - `dispatch(command: Command) -> void`: Dispatches a command to the appropriate handler.

##### NFTService

- `Fields`
  - `state: NFTsState`
  - `event_store: EventStore`
  - `dispatcher: CommandDispatcher`

- `Actions`
  - `create(state: NFTsState, event_store: EventStore, dispatcher: CommandDispatcher) -> void`: Creates a new instance of NFTService.
  - `handle_command(command: Command) -> void`: Handles a command by dispatching it to the appropriate handler.
  - `get_nft_owner(hash: checksum256) -> name`: Returns the owner of an NFT with the given hash.

#### Event

##### DomainEventType

- `Variants`
  - `NFT_MINTED`
  - `NFT_TRANSFERED`

##### DomainEvent

- `Fields`
  - `evnt_type: DomainEventType`
  - `evnt_payload: vector<char>`

- `Actions`
  - `create(evnt_type: DomainEventType, evnt_payload: vector<char>) -> void`: Creates a new instance of DomainEvent.
  - `serialize() -> vector<char>`: Serializes the domain event to a byte array.

#### Store

##### AggregateRepository

- `Fields`
  - `event_store: EventStore`

- `Actions`
  - `create(event_store: EventStore) -> void`: Creates a new instance of AggregateRepository.


🌟 **Ecosystem Fit:** 🌟

🔹 **Project's Fit:** CILA will provide an infrastructure for building efficient omnichain smart contracts that can be integrated into the EOS ecosystem, offering a unique solution in the EOS Ecosystem landscape.

🔹 **Target Audience:** Developers interested in building omnichain smart contracts on EOS particularly those looking to develop multi-chain applications and interact with multiple blockchain networks.

🔹 **Project's Purpose:** The infrastructure will enable developers to build more efficient and scalable omnichain smart contracts, making it easier to create multi-chain applications that interact with multiple blockchain networks. This will help solve the problem of siloed blockchains and allow developers to take advantage of the benefits of multiple chains.

🔹 **Similar Projects:** We are not aware of any other projects similar to CILA OmniChain in the EOS ecosystem, offering a unique solution for building omnichain smart contracts. 

## Team 🦾

### Team members

- 👨‍💻 Alex Shkor - Architect, Developer, Team Lead
- 👨‍💻 Alexey Kulik - Architect, Developer
- 👩‍💼 Julia Shinkevich - Project Manager
- 🧑‍💼 Max Slyzkoukh - Product Manager
- 👨‍🔧 Yahor Tsaryk - Engineer

### Legal Structure

- **Registered Address:** 16192 Coastal Highway, Lewes, DE 19958, United States.
- **Registered Legal Entity:** Collective Intelligence Labs Inc.

### Team's experience

Our team's extensive experience in blockchain development and past successful projects make us well-suited for this project. We have developed several blockchain-based platforms, including DeSci, which offers a decentralized scientific communication infrastructure, and IPledger, which registers intellectual property assets on the blockchain. We have also built a Proof of Share protocol for verification on a chain that specific files have been shared between parties, an on-chain grants distribution platform, a decentralized technology transfer platform, F-NFT and Event Proxy, and other projects.

Our team members have also contributed to open-source blockchain projects, demonstrating our commitment to the development of the blockchain ecosystem as a whole.

Our Team Lead is distributed systems architect and has over 14 years of experience in this field, with one of our team members being the inventor of omnichain smart-contracts protocol, which is an important aspect of this project. Our Software Engineer has over 10 years of experience in distributed systems engineering and was the ex-CTO at DEIP and the creator of the Economy Protocol. Our Tech Lead has experience in distributed system and blockchain R&D and was the ex-Head of R&D at Paralect, while also having experience as an ex-CPO at DEIP. Our Head of Marketing has 9 years of experience in PR and communications, having worked with micromobility and web3 startups. Our Product Manager expert in digital transformation has 6 years of experience in the procurement of 50+ leading private and state Ukrainian enterprises.

We are confident that our team's expertise and experience in developing distributed systems and infrastructure will enable us to successfully execute our proposed CILA omnichain infrastructure project. We believe that this infrastructure is crucial for the growth and adoption of blockchain technology, and we are excited about the opportunity to contribute to this space. 

### Team Code Repos

- https://github.com/Collective-Intelligence-Labs

### Team GitHub Profiles


- https://github.com/alexshkor
- https://github.com/aliakseikulik
- https://github.com/yahortsaryk
- https://github.com/juliacil

### Team LinkedIn Profiles

- https://www.linkedin.com/in/alexshkor/
- https://www.linkedin.com/in/alexeykulik/
- https://www.linkedin.com/in/julia-shinkevich/
- https://www.linkedin.com/in/max-slyzkouh/
- https://www.linkedin.com/in/yahor-tsaryk-92032a68/ 


## Development Status :open_book:

CILA omnichain infrastructure for EOS is currently in the research and planning phase. We have conducted extensive research on the existing smart contract infrastructure and identified the need for an omnichain smart contract solution. Our team has also analyzed the capabilities of the EOS/ecosystem and determined that it is the ideal platform for building this solution.

We have created a detailed project plan that outlines the development roadmap and milestones. This plan includes research and development of the necessary components.

- Draft of solidity implementation: https://github.com/Collective-Intelligence-Labs/cila-sol-contracts
- Vision Paper: https://docsend.com/view/eqt2iazwmff3jikh

## Development Roadmap :nut_and_bolt:

### Overview

- **Total Estimated Duration:** 6 months
- **Full-Time Equivalent (FTE):** 3 FTE
- **Total Costs:** 99,000 USD

### Milestone 1 — Design and Implementation

- **Estimated duration:** 2 month
- **FTE:**  3
- **Costs:** 45,000 USD

| Number | Deliverable | Specification |
| -----: | ----------- | ------------- |
| **0a.** | License | Apache 2.0 |
 **0b.** | Documentation | We will ensure comprehensive documentation of the code by providing both inline comments and a step-by-step tutorial. This tutorial will guide the user through spinning up a EOS-based execution environment for the CILA Omnichain Infrastructure and testing omnichain transactions, showcasing the new functionality. |
| **0c.** | Testing and Testing Guide | We will conduct comprehensive unit testing on the core functionalities including Aggregate, Event Store, Aggregate Repository, Snapshot Store, and Dispatcher, to ensure optimum functionality and robustness. The testing guide will contain instructions on how to execute these tests. |
| **0d.** | Docker | We will deliver Dockerfiles for testing all the functionality included in this milestone. |
| 1. | EOS smart-contract: Aggregate | The Aggregate smart-contract provides the base functionality for implementing the Command Query Responsibility Segregation (CQRS) pattern on a EOS-based blockchain. It defines the Aggregate trait, which is used to define the state and behavior of an Aggregate. |
| 2. | EOS smart-contract: AggregateState | The AggregateState smart-contract provides a default implementation of the AggregateState trait, which stores the current state of an Aggregate in the blockchain's storage. This smart-contract is responsible for managing the state of an Aggregate and updating it based on incoming commands. |
| 3. | EOS smart-contract: AggregateRepository | The AggregateRepository smart-contract provides an implementation of the AggregateRepository trait, which is responsible for retrieving and storing Aggregates in the blockchain's storage. It allows developers to easily store and retrieve Aggregates from the blockchain's storage. |
| 4. | EOS smart-contract: CommandDispatcher | The CommandDispatcher smart-contract provides a way to dispatch incoming commands to the appropriate Aggregates based on their type. It uses a HashMap to store the mapping between command types and the Aggregates that handle them. |
| 5. | EOS smart-contract: EventStore | The EventStore smart-contract provides a way to store and retrieve events that have been emitted by Aggregates. It allows developers to easily retrieve the events emitted by a specific Aggregate and replay them to reconstruct the current state of the Aggregate. |
| 6. | EOS smart-contract: EventsEmitter | The EventsEmitter smart-contract provides a way for Aggregates to emit events. It defines a trait that Aggregates can implement to specify the types of events they emit, and provides a way to subscribe to events emitted by specific Aggregates. |
| 7. | EOS smart-contract: SnapshotStore | The SnapshotStore smart-contract provides a way to store and retrieve snapshots of Aggregates. It allows developers to easily retrieve the latest snapshot of an Aggregate and use it to reconstruct the current state of the Aggregate. |
| 8. | EOS smart-contract: SnapshotStore | The SnapshotStore smart-contract provides a way to store and retrieve snapshots of Aggregates. It allows developers to easily retrieve the latest snapshot of an Aggregate and use it to reconstruct the current state of the Aggregate. |
| 9. | User Interface: Omnichain Smart-Contracts Explorer  | We will develop an Omnichain Smart-Contracts Explorer that provides a user interface for exploring the smart-contracts on the omnichain infrastructure. This UI will allow users to browse, search, and view the details of smart-contracts, including their source code and transaction history. It will also provide a way for users to interact with smart-contracts by sending transactions and querying their state. The Omnichain Smart-Contracts Explorer will make it easy for developers and users to explore the smart-contracts on the omnichain infrastructure and understand their functionality.|
| 10. | User Interface: EOS Smart Contract Management Interface | We will develop a user interface that allows users to manage EOS smart contracts that are connected to the omnichain smart contract infrastructure. This interface will provide users with an easy way to deploy, update, and delete EOS smart contracts on the omnichain infrastructure. Users will also be able to monitor the performance of their EOS smart contracts, view transaction histories, and access other important data about their contracts. The EOS Smart Contract Management Interface will provide developers and users with a streamlined way to interact with their EOS smart contracts on the omnichain infrastructure, making it easier to manage and deploy new contracts as needed. |


### Milestone 2 — Testing and Documentation

- **Estimated duration:** 2 month
- **FTE:**  2
- **Costs:** 30,000 USD

| Number | Deliverable | Specification |
| -----: | ----------- | ------------- |
| **0a.** | License | Apache 2.0 |
| **0b.** | Documentation | We will ensure comprehensive documentation of the code by providing both inline comments and a step-by-step tutorial. This tutorial will guide the user through spinning up a EOS-based execution environment for the CILA Omnichain Infrastructure and testing omnichain transactions, showcasing the new functionality. Special attention will be given to documenting the setup and testing of multiple EOS chains running simultaneously, to test the synchronization of the state smart contract between them. |
| **0c.** | Testing and Testing Guide | We will conduct comprehensive unit testing on the core functionalities including Aggregate, Event Store, Aggregate Repository, Snapshot Store, and Dispatcher, to ensure optimum functionality and robustness. In particular, we will place emphasis on testing the infrastructure running with multiple chains to ensure that the synchronization mechanism is functioning as intended. The testing guide will contain instructions on how to execute these tests. |
| **0d.** | Docker | We will deliver Dockerfiles for testing all the functionality included in this milestone, including orchestration with multiple chains. For orchestration purposes we might use Kubernates. |
| 0e. | Article | We will publish a technical article that details the implementation of the Command-Query Responsibility Segregation (CQRS) and Event Sourcing architecture on the EOS ecosystem. The article will provide an in-depth explanation of the design choices made and the challenges faced during the implementation. It will also include a detailed walkthrough of the codebase, highlighting key areas of interest and how they fit into the overall architecture. The article will be written in a technical language that targets developers with experience in blockchain and distributed systems. |
| 1. | EOS test-chain setup | Set up and run multiple EOS test chains simultaneously to test the synchronization of a state smart contract between them. This will involve deploying the omnichain smart contract infrastructure to each chain and executing transactions on each chain to ensure that the contract state is properly synchronized between them. Additionally, various network conditions such as network latency and node failures will be simulated to test the robustness and reliability of the synchronization mechanism. The results of these tests will be recorded and analyzed to identify any potential issues and ensure that the synchronization mechanism is functioning as intended. |
| 2. | Overall Performance Dashboard: | We will develop an interface that will allow users to see the overall performance of the EOS Omnichain smart contract and compare it with other omnichain smart contracts implementation on different chains. The dashboard will provide real-time monitoring of key performance metrics, such as transaction throughput, latency, and resource utilization. It will also allow users to drill down into specific time periods and analyze performance trends over time. The dashboard will help users optimize the performance of their smart contracts and identify potential issues before they become critical. |
| 3. | Smart Contract Comparison Tool: | We will develop a tool that allows users to compare the performance of their EOS Omnichain smart contract with other similar smart contracts on different chains. The tool will provide a detailed analysis of key performance metrics, such as transaction throughput, latency, and resource utilization. It will also allow users to filter and sort the results by various criteria, such as contract type, chain, and transaction volume. The tool will help users identify areas for improvement and make informed decisions about which chain to deploy their smart contract on. |
| 3. | Historical Performance Analysis: | We will develop a feature that allows users to perform historical performance analysis of their EOS Omnichain smart contract and compare it with other smart contracts on different chains. The feature will provide a graphical representation of performance trends over time, allowing users to identify patterns and correlations between different performance metrics. It will also allow users to export the data in various formats for further analysis. The feature will help users optimize the performance of their smart contracts and make informed decisions about future deployments. |


### Milestone 3 — Example Smart Contracts and Enhancements

- **Estimated duration:** 2 month
- **FTE:**  2
- **Costs:** 24,000 USD

| Number | Deliverable | Specification |
| -----: | ----------- | ------------- |
| **0a.** | License | Apache 2.0 |
| **0b.** | Documentation | Provide inline documentation of the NFTAggregate smart-contract and NFTAggregateState smart-contract code, as well as a basic tutorial that explains how a user can set up a EOS node and send test transactions to test the NFT functionalities provided by these modules. Additionally, comprehensive unit tests will be developed and documented to ensure the functionality and robustness of the NFTAggregate smart-contract and NFTAggregateState smart-contract. A testing guide will also be provided, describing how to run the tests. |
| **0c.** | Testing and Testing Guide |For this milestone, we will develop comprehensive unit tests to cover the core functions of the NFTAggregate module and the NFTAggregateState smart-contract. These tests will be designed to ensure the functionality and robustness of the code. The unit tests will be included in the code repository and will cover a range of scenarios to ensure that the code is thoroughly tested. For example, we will test the minting, burning, and transferring of NFTs, as well as error handling and edge cases. In the testing guide, we will provide detailed instructions on how to run these tests, including any required dependencies and setup steps. We will also include information on how to interpret the test results and what to do in the case of failures or errors.. |
| **0d.** | Docker | In order to facilitate testing and deployment of the NFTAggregate smart-contract and NFTAggregateState smart-contract, we will provide Dockerfiles that can be used to easily set up and configure a development environment. These Dockerfiles will include all the necessary dependencies and configuration to run the EOS-based blockchain with the new functionalities. |
| 1. | EOS smart-contract: NFTAggregate | The NFTAggregate smart-contract provides a way to implement Non-Fungible Tokens (NFTs) on a EOS-based blockchain. It defines a trait that NFT Aggregates can implement to specify the behavior of NFTs, including minting, burning, and transferring. |
| 2. | EOS smart-contract: NFTAggregateState | The NFTAggregateState smart-contract provides a default implementation of the state of an NFT Aggregate, which stores the current state of NFTs in the blockchain's storage. This smart-contract is responsible for managing the state of NFTs and updating it based on incoming commands. |
| 3. | User Interface: Omnichain NFT Minting/Transferring App  | We will develop an Omnichain NFT Minting/Transferring App that provides a user-friendly interface for minting and transferring NFTs on the omnichain infrastructure. The UI will allow users to mint new NFTs by specifying the name, description, and image of the NFT. It will also allow users to transfer their NFTs to other users by specifying the recipient's wallet address. The Omnichain NFT Minting/Transferring App will make it easy for users to create and manage their NFTs on the omnichain infrastructure. |


## Future Plans

In the short term, we plan to continue to develop and enhance our project to ensure its success and sustainability. This will include ongoing testing, bug fixes, and implementing additional features and improvements as needed. We will actively promote our project through various channels, including social media, blog posts, and community events.

After the completion of the proposed infrastructure, we intend to continue its development by incorporating support for multiple blockchains and introducing more advanced functionalities, such as dynamic rebalancing for aggregates. Additionally, we plan to establish partnerships with leading players in the EOS ecosystem and to integrate our omnichain infrastructure with existing projects, such as DeFi and NFT marketplaces, to further increase adoption. Finally, we will provide comprehensive documentation and support to ensure that our infrastructure is accessible and user-friendly for developers and users alike.

In the long term, we envision our project becoming a leading platform for event-centric CQRS + Event Sourcing execution environments and omnichain smart contracts on the EOS blockchain. We plan to expand our team and further invest in research and development to stay ahead of the curve and meet the needs of the rapidly evolving blockchain industry. We will continue to engage with the community and seek feedback to ensure that our project remains relevant and valuable to users. Our ultimate goal is to create a platform that is widely adopted and helps to drive the mainstream adoption of blockchain technology.

## Additional Information :heavy_plus_sign:

Overall Performance Dashboard Architecture Diagramm

![DIAGRAMM](https://i.imgur.com/B2NdMSz.png)

Possible Overall Performance view

```sql
           ___________________________________________________________________________________________
          |                                                                                           |
          |                                Overall Performance Dashboard                              |
          |___________________________________________________________________________________________|
          |   ___________________________________________________________         _________________   |
          |  |                                                           |       |                 |  |
          |  |          Real-Time Monitoring of Key Performance Metrics  |       |                 |  |
          |  |___________________________________________________________|       |                 |  |
          |                                                                      | Drill Down into |  |
          |                                                                      | Specific Time   |  |
          |                                                                      | Periods and     |  |
          |                                                                      | Analyze         |  |
          |                                                                      | Performance     |  |
          |                                                                      | Trends over     |  |
          |                                                                      | Time            |  |
          |                                                                      |                 |  |
          |                                                                      |                 |  |
          |                                                                      |                 |  |
          |______________________________________________________________________|_________________|  |
          |                                                                                           |
          |                               EOS Omnichain Smart Contract                                |
          |___________________________________________________________________________________________|
          |                                                                                           |
          |                               Smart Contract Metrics                                      |
          |                                                                                           |
          |  Transactions per second      |        Resource Utilization    |         Latency          |
          |                               |     CPU Utilization:  70%      |                          |
          |          2000                 |     RAM Utilization:  80%      |        600 ms            |
          |_______________________________|________________________________|__________________________|
          |                                                                                           |
          |                                 Performance Trend                                         |
          |___________________________________________________________________________________________|
          |                                                                                           |
          |                  Time                          |             Transaction Throughput       |
          |                                                |                                          |
          |     12:00 AM          6:00 AM          12:00 PM          6:00 PM          12:00 AM        |
          |                                                                                           |
          |      500                 1000             1500               2000                2500     |
          |___________________________________________________________________________________________|

```

**How did you hear about the Grants Program?** Google
